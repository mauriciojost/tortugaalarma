\documentclass[12pt,a4paper,final,onecolumn]{article}


\usepackage[ansinew]{inputenc}
\usepackage[spanish,activeacute]{babel}
\usepackage{fancyhdr}                      %Paquete para gestionar

\usepackage{color}
\usepackage{graphicx}
\usepackage{anysize}
\usepackage[T1]{fontenc}
\usepackage{booktabs}
\usepackage{tabulary}


%avant, avantgar, bookman, chancery, charter, courier, helvet, helvetic, ncntrsbk, newcent, palatcm, palatino, pifont, %times, utopia, zapfchan. Modo de uso: \usepackage{avant}, etc.

%\usepackage{charter}

\usepackage{emerald}
\usepackage{utopia}


\usepackage[dvipdfm,bookmarks=true,bookmarksnumbered=true,
 pdfkeywords={TeX; dvipdfmx; hyperref; color;},%
 colorlinks=true,linkcolor=blue]{hyperref}




% Encabezado.
%\marginsize{2cm}{2cm}{2cm}{2cm}                            % Márgenes -> izq, der, sup, inf.
\title{Transformada Rápida de Fourier con Paralelismo}      % Usado por \maketitle.
\author{Mauricio Jost}                                      % Usado por \maketitle.
\date{2009}                                                 % Usado por \maketitle.


% Cuerpo.
\begin{document}

\pagestyle{empty}


%\maketitle     % Escribe el título.
\begin{center}
% Uso de tamaños (mediante ambientes): small, normalsize, large, Large y LARGE.



\begin{LARGE}
\bigskip\bigskip\bigskip\bigskip    % Espacios grandes.
Trabajo Práctico Final\\
\bigskip\bigskip
\textbf{Transformada Rápida de Fourier con Paralelismo}\\
\bigskip\bigskip
\end{LARGE}

\begin{Large}Sistemas Operativos II\\\end{Large}
\bigskip\bigskip

\begin{figure}[htp]
\centering
\includegraphics[scale=0.4]{UNC.jpg}
\end{figure}

\begin{normalsize}
Facultad de Ciencias Exactas, Físicas y Naturales\\
UNC
\end{normalsize}

\vfill  % Rellena hasta que el bloque siguiente llegue al final.

\begin{large}
\textbf{Mauricio G. Jost}\\
\bigskip\bigskip\bigskip
2009\\
\end{large}
\end{center}
\newpage                                                    % Nueva página.

\fancypagestyle{plain}
{
    \fancyhf{}
    \fancyhead[R]{\bfseries \rightmark}
    \fancyhead[LE]{\bfseries \leftmark}
    \fancyhead[LO]{\ECFTeenSpirit Jost}         %Encabezado
    \fancyfoot[C]{\bfseries \thepage}       %Pie de página

    \renewcommand{\headrulewidth}{1pt}      %Linea en el encabezado
    \renewcommand{\footrulewidth}{1pt}      %Linea en el pie de pagina.
}

\pagestyle{plain}


\tableofcontents


\newpage

\setcounter{page}{1}
\section{Introducción}

Los algoritmos de FFT son múltiples, y existen tantos como cantidad
de arquitecturas de computadoras. El presente trabajo pretende realizar la implementación
del mismo, pero no haciendo hincapié en recursos específicos de determinada
arquitectura, sino en características más bien generales, presentes en casi todos los
sistemas multiprocesadores de la actualidad.

El fin es naturalmente aumentar el grado de utilización de los recursos en esta clase de
sistemas, pero sin perder portabilidad. MPI es una herramienta que cumple con estos
enunciados, y a la cual se ha recurrido para la implementación final, siguiendo así los
lineamientos de la materia.

\newpage
\section{Marco Teórico: FFT}

\subsection{Usos de DFT y FFT}

La DFT posee una gran utilidad, que radica en la posibilidad de aplicar filtrados y otros
tipos de procesamiento a señales obtenidas de cualquier tipo de fuente analógica, pero en
un dominio de frecuencias. Esto en muchos casos facilita la interpretación del problema por
parte del programador, lo cual ayuda a lograr algoritmos más abstractos y de mejores
resultados.

Sin embargo, la Transformada Rápida de Fourier (FFT) constituye uno de los cálculos más
habituales en el tratamiento de señales digitales. Es una forma eficiente de obtener la
Transformada Discreta de Fourier (DFT). Genera el mismo resultado que se obtiene con la DFT.
La FFT puede definirse como un reajuste matemático de la DFT para una obtención del mismo
resultado a través de menos operaciones matemáticas, y por ello menos tiempo computacional.


\subsection{Enfoque del diseño del algoritmo}

Si bien el volumen de procesamiento involucrado para obtener la DFT se reduce con el algoritmo
de FFT, sigue siendo este altamente costoso en términos de tiempo. En la actualidad existen
varias alternativas para implementar la FFT, desde código en conocidos lenguajes como C, C++
o Fortran, pasando por implementaciones en ensamblador (las más habituales, orientadas
específicamente a procesadores DSP), y hasta implementaciones en hardware, con lenguajes
como Verilog o VHDL.

No es intención del autor lograr la máxima eficiencia para un sistema dado, sino lograr un
algoritmo que tenga buena respuesta general, en cualquier sistema multiprocesador moderno.

\subsection{Implementación de FFT}
Para el procesamiento de N muestras $x_{(n)}$ (N debe ser potencia de 2), se tiene
la siguiente ecuación para la obtención de su DFT:

\begin{equation}
\label{E:DFT}
	X_{(k)} = \sum_{n=0}^{N-1} x_{(n)} e^{-\frac{j2\pi}{N}} \quad , \quad 0\leq k\leq{N-1}
\end{equation}
El factor
\begin{equation}
	e^{-\frac{j2\pi}{N}} = \omega_N^{kn}
\end{equation}
es llamado \textit{phase factor}.
Este factor presenta periodicidad, y cierta simetría que no es aprovechada por DFT, pero sí por FFT.
\begin{itemize}
\item Propiedad de simetría: $\omega_N^{k+N/2} = -\omega_N^{k}$
\item Propiedad de periodicidad: $\omega_N^{k+N} = \omega_N^{k}$
\end{itemize}
Este hecho permite que la cantidad total de multiplicaciones y sumas necesarias para el resultado final, disminuya.

Como consecuencia final de la utilización de estas propiedades, se obtiene que la Ecuación \ref{E:DFT}
pueda expresarse (definida por partes) de la siguiente manera:

\begin{equation}
\label{E:FFT1}
    X_{(2k)} = \sum_{n=0}^{\frac{N}{2}-1}[x_{(n)} + x_{(n+\frac{N}{2})}], \quad k=0,1,\dots,\frac{N}{2}-1
\end{equation}
\begin{equation}
\label{E:FFT2}
    X_{(2k+1)} = \sum_{n=0}^{\frac{N}{2}-1}[x_{(n)} - x_{(n+\frac{N}{2})}], \quad k=0,1,\dots,\frac{N}{2}-1
\end{equation}

La aplicación de estas ecuaciones a un conjunto de muestras $x_{(n)}$ está representado en la Figura \ref{F:Etapas}. El proceso entero requiere $\log_2{N}$ etapas de diezmado (DFT).

La siguiente Figura describe el sentido práctico de las ecuaciones \ref{E:FFT1} y \ref{E:FFT2}.


\bigskip
\begin{figure}[htp]
\centering
\includegraphics[scale=0.45]{etapas.jpg}
\caption{
\small
Etapas de la FFT ($N=8$).}
\label{F:Etapas}
\end{figure}
\bigskip


Cada una de las etapas involucra $\frac{N}{2}$ mariposas del tipo mostrado en la Figura (\ref{F:Mariposa}).


\bigskip
\begin{figure}[htp]
\centering
\includegraphics[scale=0.50]{mariposa.jpg}
\caption{
\small
Mariposa para diezmado en frecuencia. Constituye el bloque básico para el algoritmo de FFT.}
\label{F:Mariposa}
\end{figure}
\bigskip

\subsection{Recursividad}
El algoritmo puede ser llevado a una forma recursiva. Así, en cada etapa, se realizan dos llamadas a la misma función
de origen. Esta forma de escribir el algoritmo facilita mucho su abordaje conceptual.

\bigskip
\begin{figure}[htp]
\centering
\includegraphics[scale=0.65]{recursividad.jpg}
\caption{
\small
Recursividad de FFT con diezmado en frecuencia. Ejemplo con vector de 8 muestras.}
\label{F:Recursividad}
\end{figure}
\bigskip

Existen muchas implementaciones escritas en base a bucles, en búsqueda de eficiencia. Por desgracia estas son un tanto más difíciles de desglosar, y su paralelización requiere de un cuidado extremo. En el corriente trabajo se ha optado por algoritmos recursivos, que permiten divisar fácilmente la esencia de la idea sobre la cual fueron construidos.
En la Figura \ref{F:Recursividad} se puede observar el conjunto de llamadas a una función recursiva DFT.

Notar que en cada etapa se produce una bifurcación de los datos a nivel de dependencias entre ellos. Esto se ha utilizado para generar paralelismo de grano grueso de sincronización. También es importante destacar que una vez logrado el último nivel de recursividad, los datos requieren de un ordenamiento especial antes de ser reagrupados.

\subsection{Paralelismo}


Como se puede observar en la Figura \ref{F:Etapas}, no existe dependencia entre dos bloques de datos luego de una bifurcación. Esto permite que los hilos o procesos que llevan a cabo las tareas para cada bloque, no requieran sincronizaciones tan frecuentes, o dicho de otra forma, presenten una granularidad alta de sincronización. Las condiciones de paralelismo de este algoritmo son favorables desde este punto de vista.

Sin embargo, antes de la bifurcación, no es sencillo lograr procesamiento paralelo que brinde mejoras considerables. Esto es a causa de que en etapas iniciales, la granularidad es fina. La interdependencia de los datos es alta, lo cual hace necesario un algoritmo bastante más complejo que las coordine, y de una sobrecarga no menor.

\subsubsection{Etapas de DFT con Paralelismo}

En este trabajo se ha optado por buscar la eficiencia desde la simpleza y la casi nula sobrecarga de sincronización. Esto implica que el algoritmo no es capaz de distribuir el trabajo entre una cantidad arbitraria de procesadores, sino únicamente para una cantidad $N_p$ donde $N_p = 2^v$ con $v$ entero (en otras palabras, $N_p$ debe ser potencia de 2). De esta forma, se puede distribuir los trabajos sin una sobrecarga considerable, y hacer que cada tarea tenga un grado de dependencia muy bajo respecto de su tarea par, aquella que surgió de la misma bifurcación. También se logra un
balance de carga que mejora con el aumento de la cantidad de muestras. Esto puede apreciarse en la Figura \ref{F:balance_ejemplo}, presente en las secciones siguientes.

En la Figura \ref{F:Etapas} se puede ver que es necesario luego de la última etapa de DFT, realizar un reordenamiento de los datos antes de presentarlos. El método que permite obtener la secuencia de índices es el \textit{Bit Reversal}. El ordenamiento en sí, puede consumir un tiempo importante, y es por ello que se ha optado por paralelizar también su ejecución.

\subsubsection{\textit{Bit Reversal} con Paralelismo}

El método utilizado para lograr una ejecución más rápida del algoritmo de ordenamiento es sencillo. Consiste en
agrupar los datos desordenados (u ordenados de una forma no útil) luego de todas las etapas de DFT, y volver a distribuirlos para que cada procesador reordene una parte determinada del bloque final.
Cada procesador tomará datos de todo el conjunto desordenado, según su propio cálculo de \textit{Bit Reversal},
y los agrupará en un bloque que, agrupado de forma contigua con el resto de los bloques procesados por el resto
de los procesadores, resultará en el bloque final con el orden deseado.

\subsection{Balance de carga}

Para obtener cierto balance de carga, se ha optado por una \textit{asignación parcial de tareas}.
En el momento en que todas las mariposas de una cierta etapa han sido calculadas, se procede a asignar cada bloque
resultante (de dos), a diferentes procesos. La regla a seguir es sencilla:

\begin{enumerate}
\item Siempre parte con el conjunto de mariposas de la etapa 1° el proceso \textit{root}.
\item Llegado el momento de la bifurcación, se reasignan tareas. El bloque superior (siguiendo la Figura \ref{F:Etapas}) se mantiene en el proceso actual.
    El bloque inferior, en caso de haber aún procesos ociosos, es asignado a uno de ellos. La regla de asignación está asociada a la correspondencia que tiene cierto proceso, a cierto \textit{bloque básico de asignación}\footnote{Ejemplo: se desea conocer el procesador asignado al bloque con inicio en 192. En caso de tener $N_P=8$ procesadores y $N_M=256$ muestras, la regla asigna al bloque con inicio en 192 el procesador $192\frac{N_P}{N_M} = 192\frac{8}{256} = 6$.}.
\item Una vez que se han ocupado todos los procesos existentes, las asignaciones permanecen sin modificación.
\end{enumerate}

La ecuación utilizada para obtener el proceso responsable de tratar cierto bloque está dada por:

\begin{equation}
\label{E:responsabilidad}
    P_{id} = B_{inicio}\frac{N_P}{N_M}
\end{equation}

donde:\\
$P_{id}$ es el número de proceso.\\
$B_{inicio}$ es el punto inicial del bloque.\\
$N_P$ es la cantidad de procesos.\\
$N_M$ es la longitud de la muestra (en coeficientes).\\

La siguiente Figura muestra un ejemplo.

\bigskip
\begin{figure}[htp]
\centering
\includegraphics[scale=0.65]{balance_16_4_.jpg}
\caption{
\small
Ejemplo de balance de carga para el caso de $N_p=4$ y  $N_{muestras}=16$. Con
color más oscuro se pueden observar las asignaciones al proceso \textit{root}.
Cada círculo representa un dato calculado por el procesador indicado.}
\label{F:balance_ejemplo}
\end{figure}
\bigskip


Nótese en la Figura \ref{F:balance_ejemplo} que el algoritmo es imparcial al inicio.
A medida que se avanza en las etapas la carga es mejor balanceada.
Al momento de alcanzar la unidad mínima de distribución de trabajo ($\frac{N_{muestras}}{N_p} = 4$ para el ejemplo)
el trabajo deja de distribuirse, y cada procesador continua con la totalidad de las DFT asociadas al sub-bloque, y a sus sub-bloques.


\section{Mediciones}
Las mediciones tomadas muestran tiempos en [Seg\footnote{\textit{Seg.} es la unidad entregada por la función ANSI C \textit{clock\_t clock()} dividida entre \textit{CLOCKS\_PER\_SEC}. Es usada a los efectos de establecer comparaciones entre dos algoritmos, y no se pretende con ella sugerir tiempos absolutos de ejecución.}] para diferentes tamaños de vector, y para diferente cantidad de procesadores.


\begin{table}[htp]
\centering
\begin{center}
  \scriptsize
  \begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|c|c|c|}
    \hline
    Muestras & 16Ki&32Ki& 64Ki & 128Ki&  256Ki&  512Ki& 1Mi& 2Mi& 4Mi& 8Mi& 16Mi& 32Mi& 64Mi\\
    \hline
    1 uP     & 0.01&0.02&0.05&0.13&0.31&0.72&1.54&4.41&7.30&16.62&34.90&70.57&154.36\\
    2 uP     & 0.01&0.02&0.04&0.12&0.21&0.45&0.92&2.00&4.33& 9.12&19.46&38.68&>10min\\
    \hline
  \end{tabular}
\end{center}
\small
\caption{Mediciones. Tiempos en [seg*].}
\label{T:Tabla_mediciones}
\end{table}

La aparentemente inexplicable medición obtenida para 2uP y 64Mi muestras, es causada por falta de memoria principal. Para ciertas etapas del algoritmo, cada proceso requiere volúmenes grandes de memoria (por ejemplo al hacer \textit{bit reversal}). No disponer de esa memoria implica la utilización de memoria de intercambio (memoria secundaria), y por ende aumentos imprevistos de tiempo de ejecución.

La siguientes figuras muestran estos resultados.



\bigskip
\begin{figure}[htp]
\centering
\includegraphics[scale=0.75]{mediciones0_2K.jpg}
\caption{
\small
Mediciones de la FFT con paralelismo realizadas en una PC Notebook HP530, CoreDuo 1.66 GHz, 2GiB RAM, SO Fedora 10.}
\label{F:mediciones}
\end{figure}
\bigskip

\bigskip
\begin{figure}[htp]
\centering
\includegraphics[scale=0.75]{mediciones0_30K.jpg}
\caption{
\small
Mediciones de la FFT con paralelismo realizadas en una PC Notebook HP530, CoreDuo 1.66 GHz, 2GiB RAM, SO Fedora 10.}
\label{F:mediciones}

\end{figure}
\bigskip







\newpage
\begin{thebibliography}{9}

\bibitem{B:Wikipedia} Wikipedia, \emph{Fast Fourier transform}, \url{http://en.wikipedia.org/wiki/Fast_Fourier_transform}.

\bibitem {B:Mohammed} Carleton University, Mohammed Aboul-Magd, \emph{Recursive Fast Fourier Transform Algorithm}, \url{http://www.scs.carleton.ca/~maheshwa/courses/5703COMP/Seminar08/mohammed-reprt.pdf}. Pg. 5.

\bibitem{B:Taiwan} National Taiwan University, \emph{Fast Fourier Transform (FFT)}, \url{http://www.cmlab.csie.ntu.edu.tw/cml/dsp/training/coding/transform/fft.html}.

\bibitem{B:Recurs} FSU Computer Science, \emph{Efficient FFT Implementations},
\url{http://www.cs.fsu.edu/~cop4531/slideshow/chapter32/32-3.html}.

\bibitem{B:Proakis} Proakis, J. G. y Manolakis, D. G., 2003. \emph{Tratamiento Digital de Señales}. Tercera Edición. Prentice Hall. Madrid.

\bibitem{B:CatDSP} Cátedra de DSP - FCEFyN (UNC). Apunte \emph{Transformada de Fourier y el Algoritmo FFT}, \url{http://www.dsp.efn.unc.edu.ar/documentos/FFT.pdf}.

\end{thebibliography}




\end{document}             % End of document.
